function [combined_V , combined_F ,TR] = DataWithName( raw_data ,smoothing_factor , data_name )

%inputs:
%raw_data : one column data, in Csv ot txt format
%smoothing_factor
%data_name: the name that want to be on the STL version

%outputs:
%combined_V: Faces generated from the data points
%combined_F: Vertices generated from the data points
%TR: Triangulated objects ready for exporting the STL format

data = raw_data;

% Turn the data table into array
data = table2array(data) ;

% Extracting relative X and Y from Z matrix
[x, y] = meshgrid(1:size(data, 2), 1:size(data, 1));

% Lowering the number of data by decimation
decimationFactor = 2;
y_decimated = y(1:decimationFactor:end, :);
x_decimated = x(1:decimationFactor:end, :);
z_decimated = data(1:decimationFactor:end, :);

% Apply Gaussian smoothing
z_smoothed = imgaussfilt(z_decimated, smoothing_factor);

% Scaling
% This process have 2 parts, first defining an scale factor and then scaling
% Scale factors for X and Y are defined in away that the final X and Y size would be 150 and 100
% The Z height is the mean of the X and Y
%X
x_ScaleFactor = 150 / max (x_decimated(:));
x_scaled = x_decimated * x_ScaleFactor;
%Y
y_ScaleFactor = 100 / max (y_decimated(:));
y_scaled = y_decimated * y_ScaleFactor;
%Z
z_ScaleFactor = ((100 + 150)/2) / max(z_smoothed(:)) ; %defining a scale factor to multiply all the Z and height to it (this transform the highest point of the graph to be mean of the X and Y size)%This make the printing easily
z_scaled = z_smoothed * z_ScaleFactor ; %scale all the Z data

% Flatten for triangulation
vertices = [x_scaled(:), y_scaled(:), z_scaled(:)]; %make vertices out of the data points(make a new matrix out of 3 matrix(each row is a 3D point
valid_indices = all(isfinite(vertices), 2); %remove unidentified values
vertices = vertices(valid_indices, :); %keeping the rows of the matrix with valid values

% Generates a Delaunay triangulation using the X and Y coordinates from the vertices matrix
faces = delaunay(vertices(:, 1), vertices(:, 2));

% Create a solid volume from positive data
[F_solid, V_solid] = surf2solid(faces, vertices, 'elevation', -6); %2 is theheight of solid bottom(can be changed based on the data)

% Create Solid Cube
% Creating a solid cube which the x dimension is 130 and y simension is 180
%the height of the cube is 5
vertices = [0 0 0;
    130 0 0;
    130 180 0;
    0 180 0;
        0 0 5;
        130 0 5;
        130 180 5;
        0 180 5];

    %2D triangulation using x and y points
    faces = delaunay(vertices(:, 1), vertices(:, 2));

    % Converting the surface into solid using surf2solid command
    % Put the elevation 10 and generating solid faces and solid vertices
    [Solid_faces, Solid_vertices] = surf2solid(faces, vertices, 'elevation', 10);

    % Create 3D Text Letter by Letter
    % Get the inout letters
    letters = char(data_name);
    fontSize = 15; %font size
    depth = 5; %the amount of extruding
    spacing = 12; %the spacing between each character
    startY = 0; %the starting point

    %for making the letters as standing ones we need a matrix to multiply and
    %turn the upright
    R = [cos(pi/2) 0 sin(pi/2); 0 1 0; -sin(pi/2) 0 cos(pi/2)];

    %make an empty cells for the words
    %creates a cell which has 1 row and length * 2 column
    %*2 = 2 vertices, one for back and one for front(like faces)
    all_text_vertices = cell(1, length(letters)*2);
    all_text_faces = cell(1, length(letters)*2);

    %how many vertices have already been added
    vertex_offset = 0;

    %Track where you are in your list of geometry pieces
    face_idx = 1;


    for i = 1:length(letters)

        if letters(i) == ' ' %check if the character is blank
            startY = startY + spacing;%change the starting point

            %if the characters is space, then when its reached to this line it
            %will start over a new iteration in for loop
            continue
        end

        %turn the text into numbers and matrix(its not binary yet)
        %generate a RGB one
        %generate a 50 Ã— 50 gray scale which the insert text will return it
        %into RGB
        %starting point is (0 , 0)
        %adjusting the font and font size
        %turn the background opocity to zero
        %the text colors are white
        img = insertText(zeros(50,50), [0 0], letters(i), ...
            'FontSize', fontSize,'Font', 'Arial Black', ...   % Use a naturally bold font
            'BoxOpacity', 0, ...
            'TextColor', 'white');

        %make the RGB into gray + make the image binary
        BW = imbinarize(rgb2gray(img));
        %rotating 270 degree and flip it
        %this is essential for showing the letters
        BW = imrotate(BW, 270);
        BW = fliplr(BW);
        %extract the boundary coordinates of white shapes
        B= bwboundaries(BW, 'noholes');
        %placing a letters in 130 x, change the starting point for the next
        %letter , and Z in 0
        pos = [130; 10 + startY; 0];

        %looping through all detected boundaries in the binary image
        for k = 1:length(B)
            % reduces the number of points
            boundary = B{k}; % downsample for speed

            %extracting x and y
            x = boundary(:,2);
            y = boundary(:,1);
            z0 = zeros(size(x)); %create zero z matrix
            z1 = depth * ones(size(x)); %create the matrix of z with depth
            %the bottom face
            %make a matrix of x,y,and z which each are in a row
            %multiply to a matrix which make it stands upright
            coords0 = R * [x'; y'; z0'];
            %the top face
            coords1 = R * [x'; y'; z1'];
            minZ = min(coords0(3,:));%find min z
            coords0(3,:) = coords0(3,:) - minZ; %shifting z to be zero
            coords1(3,:) = coords1(3,:) - minZ; %shifting z to be zero
            coords0 = coords0 + pos; % turn the x to be 130, shift the y
            coords1 = coords1 + pos; % turn the x to be 130, shift the y
            %gets the number of columns, i.e., the number of points around the boundary
            %This number is important for building the side walls of the extruded mesh
            n = size(coords0, 2);
            v0 = coords0'; %This represents the bottom face of the extruded letter.
            v1 = coords1'; %Same for the top face
            all_text_vertices{face_idx} = [v0; v1]; %storing both layers of vertices in your cell array
            faces_temp = []; %Initializes an empty list of triangle faces.
            %connecting side faces
            for m = 2:n-1
                faces_temp(end+1,:) = [vertex_offset+1, vertex_offset+m, vertex_offset+m+1];
                faces_temp(end+1,:) = [vertex_offset+n+1, vertex_offset+n+m, vertex_offset+n+m+1];
            end
            %extruding side walls
            for m = 1:n-1
                a = vertex_offset + m;
                b = vertex_offset + m + 1;
                c = vertex_offset + n + m + 1;
                d = vertex_offset + n + m;
                faces_temp(end+1,:) = [a b c];
                faces_temp(end+1,:) = [a c d];
            end
            %storing the triangulated faces and matrices
            all_text_faces{face_idx} = faces_temp;
            vertex_offset = vertex_offset + 2 * n;
            face_idx = face_idx + 1;
        end
        %make the y ready for the next letter
        startY = startY + spacing;
    end
    %merging all the individual letters' geometry
    all_text_vertices = vertcat(all_text_vertices{:});
    all_text_faces = vertcat(all_text_faces{:});

    % Add Custom Object on Top of Cube
    % Assume user provides: f_solid, v_solid
    % Position custom object centered on top of cube (e.g., 75, 100, 20)
    custom_translation = [110, 20, 12];
    rotation_xy = [cosd(90) -sind(90) 0; sind(90) cosd(90) 0; 0 0 1];
    v_solid_rotated = (rotation_xy * V_solid')';
    %moving 3D object
    v_solid_translated = bsxfun(@plus, v_solid_rotated, custom_translation);
    f_solid_shifted = F_solid + size(Solid_vertices, 1) + size( ...
        all_text_vertices, 1);

    % Combine All and Export
    text_faces_shifted = all_text_faces + size(Solid_vertices, 1);
    combined_V = [Solid_vertices; all_text_vertices; v_solid_translated];
    combined_F = [Solid_faces; text_faces_shifted ; f_solid_shifted];
    TR = triangulation(combined_F, combined_V);
end %DataWithName
